import * as fs from 'node:fs';
import * as path from 'node:path';
import { IndentationText, Project, QuoteKind } from 'ts-morph';
import { generateApiClient } from './generators/api-client.js';
import { generateDtos } from './generators/dto.js';
import { extractApiClientEnums, matchEnumsToApiClient } from './generators/api-client-enums.js';
import { generateEnums } from './generators/enums.js';
import { generateModels } from './generators/models.js';
import { generateModule } from './generators/module.js';
import { generateResolver } from './generators/resolver.js';
import { generateService } from './generators/service.js';
import { toKebabCase } from './utils.js';
import { parseSpec } from './parser/parse-spec.js';
import { loadSpec } from './parser/spec-loader.js';

export interface GenerateOptions {
  overwrite?: boolean;
}

export async function generate(input: string, output: string, options?: GenerateOptions): Promise<void> {
  const outputDir = path.resolve(output);

  if (options?.overwrite) {
    fs.rmSync(outputDir, { recursive: true, force: true });
  }

  fs.mkdirSync(outputDir, { recursive: true });

  console.log('Parsing OpenAPI spec...');
  const rawSpec = await loadSpec(input);
  const spec = await parseSpec(rawSpec);

  console.log('Generating REST client...');
  const routeMap = await generateApiClient(input, outputDir);

  // Enrich parsed endpoints with actual API client method/namespace names
  for (const controller of spec.controllers) {
    for (const endpoint of controller.endpoints) {
      const routeInfo = routeMap.get(endpoint.operationId);
      if (routeInfo) {
        endpoint.apiClientMethodName = routeInfo.methodName;
        endpoint.apiClientNamespace = routeInfo.namespace;
      } else {
        console.warn(
          `Warning: No API client route mapping found for operationId "${endpoint.operationId}"`,
        );
      }
    }
  }

  // Prepend eslint-disable to api-client (generated by swagger-typescript-api, not ts-morph)
  const apiClientPath = path.join(outputDir, 'api-client.ts');
  const apiClientContent = fs.readFileSync(apiClientPath, 'utf-8');
  fs.writeFileSync(apiClientPath, `/* eslint-disable */\n${apiClientContent}`);

  const project = new Project({
    manipulationSettings: {
      quoteKind: QuoteKind.Single,
      indentationText: IndentationText.TwoSpaces,
    },
  });

  if (spec.enums.length > 0) {
    console.log('Generating enums...');
    const apiClientEnums = extractApiClientEnums(outputDir);
    const enumMatchResult = matchEnumsToApiClient(spec.enums, apiClientEnums);
    const enumsFile = project.createSourceFile(
      path.join(outputDir, 'enums.ts'),
      '',
      { overwrite: true },
    );
    generateEnums(enumsFile, enumMatchResult);
  }

  for (const controller of spec.controllers) {
    const controllerDir = path.join(outputDir, toKebabCase(controller.name));
    fs.mkdirSync(controllerDir, { recursive: true });

    const baseName = toKebabCase(controller.name);

    console.log(`Generating module: ${controller.name}...`);

    // Generate models (skip if no non-primitive response schemas)
    const hasModels = controller.endpoints.some(
      (e) => e.responseSchema && !e.responseSchema.primitiveType,
    );
    if (hasModels) {
      const modelsFile = project.createSourceFile(
        path.join(controllerDir, `${baseName}.models.ts`),
        '',
        { overwrite: true },
      );
      generateModels(modelsFile, controller, spec.schemas);
    }

    // Generate DTOs (skip if no request bodies)
    const hasDtos = controller.endpoints.some((e) => e.requestBody);
    if (hasDtos) {
      const dtosFile = project.createSourceFile(
        path.join(controllerDir, `${baseName}.dto.ts`),
        '',
        { overwrite: true },
      );
      generateDtos(dtosFile, controller, spec.schemas);
    }

    // Generate service
    const serviceFile = project.createSourceFile(
      path.join(controllerDir, `${baseName}.service.ts`),
      '',
      { overwrite: true },
    );
    generateService(serviceFile, controller);

    // Generate resolver
    const resolverFile = project.createSourceFile(
      path.join(controllerDir, `${baseName}.resolver.ts`),
      '',
      { overwrite: true },
    );
    generateResolver(resolverFile, controller);

    // Generate module
    const moduleFile = project.createSourceFile(
      path.join(controllerDir, `${baseName}.module.ts`),
      '',
      { overwrite: true },
    );
    generateModule(moduleFile, controller);
  }

  // Prepend eslint-disable to all ts-morph generated files
  for (const sourceFile of project.getSourceFiles()) {
    sourceFile.insertText(0, '/* eslint-disable */\n');
  }

  await project.save();
  console.log('Done!');
}
